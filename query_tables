-- Select only the employees who make more than 50K
select first_name, last_name from employees
where salary > 50000

-- Select only the employees who work in Common Grounds coffeeshop
select emp.first_name, emp.last_name, sh.coffeeshop_name from employees emp
inner join shops sh
on sh.coffeeshop_id = emp.coffeeshop_id 
where sh.coffeeshop_name = 'Common Grounds'

-- Select only the employees who work in Common Grounds coffeeshop AND make more than 50K
select emp.first_name, emp.last_name, sh.coffeeshop_name, emp.salary from employees emp
inner join shops sh
on sh.coffeeshop_id = emp.coffeeshop_id 
where sh.coffeeshop_name = 'Common Grounds' and emp.salary > 

-- Select only the employees who work in Common Grounds coffeeshop OR make more than 50K
select emp.first_name, emp.last_name, sh.coffeeshop_name, emp.salary from employees emp
inner join shops sh
on sh.coffeeshop_id = emp.coffeeshop_id 
where sh.coffeeshop_name = 'Common Grounds' or emp.salary > 50000

-- Select all the employees who work in Common Grounds, make more than 50K and are male
select emp.first_name, emp.last_name, sh.coffeeshop_name, emp.salary, emp.gender from employees emp
inner join shops sh
on sh.coffeeshop_id = emp.coffeeshop_id 
where sh.coffeeshop_name = 'Common Grounds' and emp.salary > 50000 and emp.gender = 'M'

-- IS, IS NOT, IN, NOT IN, IS NULL, IS NOT NULL, BETWEEN operators
select * from employees
select * from shops
select * from locations
select * from suppliers
-- Select all rows from the suppliers table where the supplier is 'Beans and Barley'
select * from suppliers
where supplier_name = 'Beans and Barley'
-- Select all rows from the suppliers table where the supplier IS NOT 'Beans and Barley'
select * from suppliers
where supplier_name != ('Beans and Barley')
-- Select all Robusta and Arabica coffee types
select * from suppliers
where coffee_type IN ('Arabica', 'Robusta')
-- Select all coffee types that are not Robusta or Arabica
select * from suppliers
where coffee_type NOT IN ('Arabica', 'Robusta')
-- Select all employees with missing email address
select first_name, last_name, email from employees
where email IS NULL
-- Select all employees whose email are not missing
select first_name, last_name, email from employees
where email IS NOT NULL
-- Select all employees who make between 35K and 50K
select first_name, last_name, salary from employees
where salary BETWEEN 35000 and 50000
-- or
select first_name, last_name, salary from employees
where salary >= 35000 and salary <= 50000

-- ORDER BY, LIMIT, DISTINCT, Renaming columns (AS)
-- Top 10 highest paid employees
select * from employees
ORDER BY salary DESC
LIMIT 10
-- Return all unique coffeeshop ids
select distinct(coffeeshop_id) from employees
-- Renaming columns
select email, email AS email_address, hire_date, hire_date AS date_joined, salary, salary AS pay
from employees

-- EXTRACT DOW, DOY, MONTH, DAY, YEAR, QUARTER, WEEK FROM columns
select hire_date,
EXTRACT (DOW FROM hire_date) AS day_of_the_week,
EXTRACT (DOY FROM hire_date) AS day_of_the_year,
EXTRACT (MONTH FROM hire_date) AS month,
EXTRACT (DAY FROM hire_date) AS day,
EXTRACT (YEAR FROM hire_date) AS year,
EXTRACT (QUARTER FROM hire_date) AS quarter,
EXTRACT (WEEK FROM hire_date) AS week
from employees

-- UPPER, LOWER, LENGTH
-- Uppercase and lowercase first and last names
select first_name, UPPER(first_name) AS first_name_upper,
	   last_name, UPPER(last_name) AS last_name_upper,
	   first_name, LOWER(first_name) AS first_name_lower,
	   last_name, LOWER(last_name) AS last_name_lower
from employees

-- Return the email and the length of emails
select email, LENGTH(email) AS email_length from employees
-- Concatenation, Case When, Wildcards
-- Concatenate first and last names to create full names
select concat_ws(' ', first_name, last_name) AS full_name from employees
-- OR
select first_name || ' ' || last_name from employees
-- Concatenate columns to create a sentence
select concat_ws(' ', first_name, last_name, 'makes', salary) from employees

-- If the employees make less than 50K, then true, otherwise false
select concat_ws(' ', first_name, last_name), salary,
CASE 
WHEN salary < 50000 THEN 'true' ELSE 'false'
END AS less_than_50K
from employees
-- If an employee is a female and makes less than 50K, then true, otherwise false
select concat_ws(' ', first_name, last_name), salary,
CASE 
WHEN salary < 50000 and gender = 'F' THEN 'true' ELSE 'false'
END AS less_than_50K_female
from employees
-- Case When with Wildcards. If the email has '.com', return true, otherwise false
select email,
CASE WHEN email LIKE '%.com%' THEN 'true' ELSE 'False'
END AS email_com
from employees

-- SUBSTRING, POSITION, COALESCE
-- Substring. Get the email from the 5th character of the email
select email, SUBSTRING(email FROM 5) from employees
-- Position. Find the position of '@' in the email
select email, POSITION('@' IN email) from employees
-- COALESCE to FILL missing values in a column
select email, 
COALESCE(email, 'NO EMAIL PROVIDED')
from employees
-- MIN, MAX, AVG, SUM, COUNT
-- Select the minimum salary
select MIN(salary) AS minimum_salary from employees
-- Select the maximum salary
select MAX(salary) AS maximum_salary from employees
-- Select difference between maximum and minimum salary
select MAX(salary) - MIN(salary) from employees
-- Select the AVG salary
select ROUND(AVG(salary),0) from employees
-- Sum up the salaries
select SUM(salary) from employees
-- Count the number of entries (countrows, count everything)
select COUNT(*) from employees

-- GROUP BY & HAVING
-- Return the number of employees for each coffee shop
select count(emp.employee_id) AS number_of_employees, sh.coffeeshop_name from employees emp
inner join shops sh
on emp.coffeeshop_id = sh.coffeeshop_id
group by sh.coffeeshop_name
-- Return the total salaries for each coffeeshop
select sum(emp.salary) AS total_salaries, sh.coffeeshop_name from employees emp
inner join shops sh
on emp.coffeeshop_id = sh.coffeeshop_id
group by sh.coffeeshop_name
order by total_salaries DESC

-- Return the number of employees, the AVG & MIN, MAX & total salaries for each of the coffeeshop
select sh.coffeeshop_name,
sum(emp.salary) AS total_salaries,
count(emp.employee_id) AS number_of_employees,
ROUND(AVG(emp.salary),0) AS rounded_average_salary,
MIN(emp.salary) AS minimum_salary,
MAX(emp.salary) AS maximum_salary
from employees emp
inner join shops sh on emp.coffeeshop_id = sh.coffeeshop_id
group by sh.coffeeshop_name
order by number_of_employees DESC

-- HAVING 
-- Return the number of employees, the AVG & MIN, MAX & total salaries for each of the coffeeshop with
-- more than 200 employees
select * from shops
select * from employees
select sh.coffeeshop_name, count(emp.employee_id) AS total_number_of_employees, 
ROUND(AVG(emp.salary),0) AS rounded_salary, MIN(emp.salary) AS minimum_salary,
MAX(emp.salary) AS maximum_salary, SUM(emp.salary) AS total_salaries
from employees emp
inner join shops sh on emp.coffeeshop_id = sh.coffeeshop_id
group by sh.coffeeshop_name
HAVING count(emp.employee_id) > 200
order by total_number_of_employees DESC
-- Return the number of employees, the AVG & MIN, MAX & total salaries for each of the coffeeshop with
-- a minimum salary of less than 10K
select * from shops
select * from employees
select sh.coffeeshop_name, count(emp.employee_id) AS total_number_of_employees, 
ROUND(AVG(emp.salary),0) AS rounded_salary, MIN(emp.salary) AS minimum_salary,
MAX(emp.salary) AS maximum_salary, SUM(emp.salary) AS total_salaries
from employees emp
inner join shops sh on emp.coffeeshop_id = sh.coffeeshop_id
group by sh.coffeeshop_name
HAVING MIN(emp.salary) < 10000
order by total_number_of_employees DESC

-- CASE, CASE with GROUP BY, and CASE for TRANSPOSING data
-- CASE 
-- If pay is less than 50K, then low pay, otherwise high pay
select employee_id, first_name, last_name, salary,
CASE 
	WHEN salary < 50000 THEN 'low_pay' 
	ELSE 'high_pay'
	END AS salary_status
from employees
order by salary DESC
-- If pay is less than 50K, then low pay, if pay is greater or equals to 50000 then low pay, 
-- otherwise no pay
select employee_id, first_name, last_name, salary,
CASE 
	WHEN salary < 50000 THEN 'low_pay' 
	WHEN salary >= 50000 THEN 'high_pay'
	ELSE 'no_pay'
	END AS salary_status
from employees
order by salary DESC

-- If pay is less than 20K, then low pay, If between 20K-50K inclusive, then medium pay.
-- If over 50K, then high pay
select * from employees
select * from locations
select * from shops
select * from suppliers
select employee_id, first_name, last_name, salary,
CASE 
	WHEN salary < 20000 THEN 'low_pay'
	WHEN salary >=20000 AND salary <=50000 THEN 'medium_pay'
	WHEN salary > 50000 THEN 'high_pay'
ELSE 'check_logic'
END AS salary_status
from employees
order by salary DESC

-- CASE, GROUP BY & JOIN
-- Return the count of employees per coffeeshop in each pay category 
select sh.coffeeshop_name,
COUNT(CASE WHEN emp.salary < 20000 THEN emp.employee_id ELSE NULL END) AS low_pay_number_of_employees,
COUNT(CASE WHEN emp.salary >= 20000 AND emp.salary <= 50000 THEN emp.employee_id ELSE NULL END) AS 
medium_pay_number_of_employees,
COUNT(CASE WHEN emp.salary > 50000 THEN emp.employee_id ELSE NULL END) AS
high_pay_number_of_employees
from employees emp
inner join shops sh on emp.coffeeshop_id = sh.coffeeshop_id
group by sh.coffeeshop_name





